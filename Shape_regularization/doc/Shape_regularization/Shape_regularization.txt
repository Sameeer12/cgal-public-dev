namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Shape_Regularization

\cgalAutoToc

\cgalFigureBegin{shape_regularization, regularize_100_segments_angles_after.png}
Shape regularization example on 100 segments. See \ref QP_regularization_2D_Angles.
\cgalFigureEnd

\authors Jean-Philippe Bauchet, Florent Lafarge, Simon Giraudot, Gennadii Sytov, Dmitry Anisimov


\section Introduction

This CGAL package enables to regularize a set of 2D segments in the plane, both open 
and closed contours, and a set of planes in 3D. By regularization we mean a process 
of aligning and rotating input objects such that they respect certain user-specified 
conditions.


\section QP_regularization QP Regularization

The shape regularization algorithm is based on the "Global regularization" algorithm
from the <a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Bauchet_KIPPI_KInetic_Polygonal_CVPR_2018_paper.pdf">
"KIPPI: Kinetic Polygonal Partitioning of Images"</a> article
written by Jean-Philippe Bauchet and Florent Lafarge at Inria.
The shape regularization algorithm works as follows:
1. Computes neighbors of each item in the data set;
2. Computes objective function values among these neighbors;
3. Solves the quadratic programming problem;
4. Sorts items into groups based on the regularized objective function values;
5. Updates items within each regularized group.

One particular instance of this algorithm is provided:
- \ref QP_regularization_2D "2D" regularization of segments.

Other instances can be added by the user, as explained below.


\subsection QP_regularization_Framework Framework

The main class `CGAL::Shape_regularization::QP_regularization` is parameterized by
- GeomTraits that specifies the Kernel type;
- InputRange that stores a range of user-defined input items;
- NeighborQuery that provides the means for accessing neighbors of an item;
- RegularizationType that determines which regularization type to apply.

The `CGAL::Shape_regularization::QP_regularization` uses the 
<a href="https://osqp.org/docs/">Operator Splitting Quadratic Program (OSQP) solver</a> 
to solve the quadratic programming problem. The <a href="https://osqp.org/docs/">OSQP solver</a>
is a very efficient QP solver that works with sparse matrices and has an open-source project 
license to any academic or commercial applications.

Using this generic framework, users can regularize any set 
of arbitrary items with their own regularization type. 


\subsection QP_regularization_Neighborhood Neighborhood

The concept `NeighborQuery` provides the means for accessing neighbors of an item. 
To create a model that respects this concept, the user has to provide an overload of the operator:

- `NeighborQuery::operator()()` that has to fill a vector with indices of all items, which 
are neighbors of the query item.


\subsection QP_regularization_Type Regularization Type

The concept `RegularizationType` determines the type of regularization which will be applied.
To create a model that respects this concept, three functions have to be defined:

- `RegularizationType::target_value()` This function computes and returns an objective 
function value between 2 neighbor items.

- `RegularizationType::bound()` This function returns a max bound on an item value that is regularized.

- `RegularizationType::update()` This function updates items with respect to the regularized item values.


\subsection QP_regularization_Examples Examples

A short example on how to use the framework.

\cgalExample{Shape_regularization/regularize_framework.cpp}

Another example shows how to use a CGAL solver instead of OSQP solver.

\cgalExample{Shape_regularization/regularize_with_cgal.cpp}


\section QP_regularization_2D Segment Regularization in 2D

This CGAL component provides the corresponding models of the concepts 
NeighborQuery and RegularizationType. In particular, it provides a way to define neighbors of a segment:

- `CGAL::Shape_regularization::Delaunay_neighbor_query_2` - finds the neighbors of each segment by constructing the 
Delaunay triangulation using the `CGAL::Delaunay_triangulation_2` class.

In addition to the NeighborQuery class, it provides 2 ways to define RegularizationType:

- `CGAL::Shape_regularization::Angle_regularization_2` - re-orients segments to preserve parallelism and orthogonality.
- `CGAL::Shape_regularization::Ordinate_regularization_2` - re-aligns segments to preserve collinearity.


\subsection QP_regularization_2D_Delaunay Delaunay neighbor query

This class finds the neighbors of each segment by constructing a 
Delaunay triangulation using the `CGAL::Delaunay_triangulation_2` class.

The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments, 
which has to be provided by the user using the `CGAL::Shape_regularization::Delaunay_neighbor_query_2::add_group()` 
function, and finds neighbors for each segment in the provided group. The Delaunay triangulation 
can be constructed only for a group of minimum 2 segments.


\subsection QP_regularization_2D_Angles Angle Regularization

This class re-orients segments to preserve parallelism and orthogonality. 
In order to apply the angle regularization on a set of segments, the user has to: 
- specify the angle bound in the constructor. The bound value
for the angle regularization has to be within the \f$[0, 90)\f$ degree interval. If no bound is provided,
a bound of \f$25^{\circ}\f$ will be set as the default value.
- add groups of segments using the `CGAL::Shape_regularization::Angle_regularization_2::add_group()` function. 
If the user does not have specific groups in mind, a vector of all indices of segments from `InputRange` 
has to be provided as one group.

\cgalFigureBegin{angle_regularization_2_example_before, regularize_100_segments_angles_before.png}
A generated set of 2D segments before the angle regularization.
\cgalFigureEnd

\cgalFigureBegin{angle_regularization_2_example_after, regularize_100_segments_angles_after.png}
A generated set of 2D segments after the angle regularization.
\cgalFigureEnd

Typical usage of the shape regularization algorithm for angle regularization consists of the following steps:
 1. Define an input range with segments;
 2. Create instances of the classes `NeighborQuery` and `RegularizationType` with the proper parameters;
 3. If using the `CGAL::Shape_regularization::Delaunay_neighbor_query_2` and `CGAL::Shape_regularization::Angle_regularization_2` classes,
 add groups of segments to those classes using the `CGAL::Shape_regularization::Delaunay_neighbor_query_2::add_group()` 
 and `CGAL::Shape_regularization::Angle_regularization_2::add_group()` functions;
 4. Create an instance of the class `CGAL::Shape_regularization::QP_regularization`;
 5. Regularize;
 6. Optional: the user can use the `CGAL::Shape_regularization::Angle_regularization_2::parallel_groups()` 
function to obtain groups of parallel segments which were created during the regularization process. 
This is important if the user wants to apply the ordinate regularization thereafter.

The following example demonstrates the usage of the shape regularization algorithm for angle regularization 
on a set of 100 randomly generated segments using the 
<a href="https://doc.cgal.org/latest/Generator/index.html">CGAL Geometric Object Generators</a>.
The entire `InputRange` is provided to the Angle regularization class as one group.
The angle regularization bound is set to \f$40^{\circ}\f$. The `CGAL::Exact_predicates_inexact_constructions_kernel`
Kernel is used in the following example:

\cgalExample{Shape_regularization/regularize_100_segments_angles.cpp}


\subsection QP_regularization_2D_Ordinates Ordinate Regularization

This class re-aligns segments to preserve collinearity. 
In order to apply the ordinate regularization on a set of segments, the user has to: 
- specify the ordinate value bound in the constructor. The bound value
for the ordinate regularization has to be within the \f$[0, \infty)\f$ interval. If no bound is provided,
a bound of \f$0.1\f$ will be set as the default value.
- add groups of parallel segments using the `CGAL::Shape_regularization::Ordinate_regularization_2::add_group()` function. 
If the user does not have parallel groups, the groups may be obtained from the angle regularization class or by using the 
`CGAL::Shape_regularization::Parallel_groups_2` class.

\cgalFigureBegin{ordinate_regularization_2_example_before, regularize_100_segments_ordinates_before.png}
A generated set of 2D segments before the ordinate regularization.
\cgalFigureEnd

\cgalFigureBegin{ordinate_regularization_2_example_after, regularize_100_segments_ordinates_after.png}
A generated set of 2D segments after the ordinate regularization.
\cgalFigureEnd

Typical usage of the shape regularization for ordinates consists of the following steps:
1. Define an input range with segments;
2. Create instances of the classes NeighborQuery and RegularizationType with the proper parameters;
3. Obtain groups of parallel segments. The user can use `CGAL::Shape_regularization::Angle_regularization_2::parallel_groups()`
or `CGAL::Shape_regularization::Parallel_groups_2::parallel_groups()` for this purpose.
4. If using the `CGAL::Shape_regularization::Delaunay_neighbor_query_2` and `CGAL::Shape_regularization::Ordinate_regularization_2` 
classes, add those groups to the aforementioned classes using the `CGAL::Shape_regularization::Delaunay_neighbor_query_2::add_group()` 
and `CGAL::Shape_regularization::Ordinate_regularization_2::add_group()` functions;
5. Create an instance of the class CGAL::Shape_regularization::QP_regularization;
6. Regularize;

The following example demonstrates the usage of the shape regularization algorithm for ordinate regularization 
on a set of 100 parallel segments located in a circle. The `CGAL::Shape_regularization::Parallel_groups_2` class
is used to obtain groups of parallel segments within the \f$1^{\circ}\f$ bound. 
The ordinate regularization bound is set to \f$0.25\f$. The `CGAL::Simple_cartesian<double>` Kernel is used
in the following example:

\cgalExample{Shape_regularization/regularize_100_segments_ordinates.cpp}


\subsection QP_regularization_2D_Examples Examples

The following examples demonstrate the usage of the shape regularization algorithm for 
both angle regularization and ordinate regularization sequentially.


\subsubsection Shape_regularization_2D_Examples_Simple Simple example

This example contains 15 2D segments. The angle and ordinate regularizations are performed on these segments
using bounds of \f$3.85^{\circ}\f$ and \f$0.1\f$ respectively. The `CGAL::Exact_predicates_inexact_constructions_kernel`
Kernel is used in the following example:

\cgalFigureBegin{simple_example_before, regularize_15_segments_before.png}
A set of 2D segments before the shape regularization.
\cgalFigureEnd

\cgalFigureBegin{simple_example_after, regularize_15_segments_after.png}
A set of 2D segments after the shape regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_15_segments.cpp}


\subsubsection Shape_regularization_2D_Examples_Advance Real data example

This example contains 65 2D segments which are constructed from a set of 2D points obtained from the
`CGAL::Shape_detection::Region_growing` algorithm.
The angle and ordinate regularizations are performed on these segments
using bounds of \f$60^{\circ}\f$ and \f$0.95\f$ respectively.
The `CGAL::Exact_predicates_inexact_constructions_kernel` Kernel is used in the following example:

\cgalFigureBegin{real_data_example_before, regularize_real_data_2_before.png}
A set of 2D segments before the shape regularization.
\cgalFigureEnd

\cgalFigureBegin{real_data_example_after, regularize_real_data_2_after.png}
A set of 2D segments after the shape regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_real_data_2.cpp}


\subsection QP_regularization_2D_Performance Performance

The shape regularization algorithm is very efficient due to the fact that it has 
a linear level of complexity to obtain the neighbors of each item and their objective 
function values and to construct the QP solver data. The <a href="https://osqp.org/docs/">OSQP solver</a> 
is also highly efficient due to the fact that it uses a custom ADMM-based first-order 
method requiring only a single matrix factorization in the setup phase and implements 
custom sparse linear algebra routines exploiting structures in the problem data.

The table below contains information about the described examples above: 

<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Example </th><th class="markdownTableHeadCenter">Number of segments </th><th class="markdownTableHeadCenter">Number of modified segments: Angle regularization  </th><th class="markdownTableHeadCenter">Number of modified segments: Ordinate regularization  </th><th class="markdownTableHeadCenter">Time (in seconds): Angle regularization </th><th class="markdownTableHeadCenter">Time (in seconds): Ordinate regularization </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_15_segments  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">0.000247   </td><td class="markdownTableBodyCenter">0.000140   </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_100_segments_angles  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A  </td><td class="markdownTableBodyCenter">0.002310   </td><td class="markdownTableBodyCenter">N/A  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_100_segments_ordinates  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A   </td><td class="markdownTableBodyCenter">0.001109  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_real_data_2  </td><td class="markdownTableBodyCenter">65  </td><td class="markdownTableBodyCenter">65 </td><td class="markdownTableBodyCenter">64  </td><td class="markdownTableBodyCenter">0.001873   </td><td class="markdownTableBodyCenter">0.000396  </td></tr>
</table>


\section QP_regularization_Utilities QP Regularization Utilities

The following utility classes are provided for the user:


\subsection Shape_regularization_Parallel_groups_2 Parallel groups

The `CGAL::Shape_regularization::Parallel_groups_2` class is created to allow users to form groups of parallel segments
without applying the shape regularization for the angle regularization algorithm. This class is parameterized as follows:
- GeomTraits that specifies the Kernel type;
- InputRange that stores a range of user-defined input items;
- SegmentMap that provides the means for accessing items from the InputRange;

In order to create groups of segments based on the principle of parallelism from a set of segments, the user has to:
- set the `tolerance` value within the \f$(0, \infty)\f$ interval. If no value is provided, the `tolerance` is set to
\f$1000000\f$. The greater the `tolerance` value becomes, the lower the grouping angle becomes, i.e. the `tolerance` value of 
\f$1\f$ is equal to the angle bound of \f$1^{\circ}\f$, the `tolerance` value of \f$10\f$ is equal to the angle bound 
of \f$0.1^{\circ}\f$ and etc.

The user can access the parallel groups using the `CGAL::Shape_regularization::Parallel_groups_2::parallel_groups()` function.


\section Plane_regularization Plane Regularization

Here we provide all currently available CGAL algorithms that enable to regularize 3D planes.


\subsection Plane_regularization_Hierarchy Hierarchical Regularization

Shape detection applies to man-made scenes or objects such as urban scenes or scans of mechanical parts. 
Such scenes often contain a wide range of geometric regularities such as parallelism, orthogonality, or symmetry. 
This package offers a function to reinforce four types of regularities for planar shapes, `CGAL::Shape_regularization::regularize_planes()`:

- Planes that are near *parallel* are made parallel: normal vectors of planes that form angles smaller than a user-defined threshold are made exactly equal;
- Parallel planes that are near *coplanar* are made exactly coplanar;
- Planes that are near *orthogonal* are made exactly orthogonal;
- Planes that are near *symmetrical* with respect to a user-defined axis are made exactly symmetrical.

The user can choose to regularize only one or several of these four properties, see CGAL::Shape_regularization::regularize_planes(). 
The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters, 
which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. \cgalCite{cgal:vla-lod-15}

The following example illustrates how to use the plane regularization global function.

\cgalExample{Shape_regularization/regularize_planes.cpp}


\section Contour_regularization Contour Regularization 

The algorithm `CGAL::Shape_regularization::Contour_regularization_2` enables to regularize 
both closed and open 2D contours. A contour is given as a set of ordered points connected by segments. A user 

- specifies a type of the contour, open or closed;
- provides or estimates the principal directions of the given contour;
- regularizes the contour.

We assume that each contour has at least one principal direction that is a reference 
direction towards which all other contour edges are either rotated or displaced. Given 
a user defined max angle threshold and max distance tolerance each segment within 
these thresholds is made either parallel/collinear or orthogonal to the reference direction.

The user can either set principal directions by specifying for each contour edge an index of 
the corresponding principal edge or he can estimate them automatically by choosing one of 
the two available estimation types

- `CGAL::Shape_regularization::Direction_type::LONGEST` - sets as principal direction 
the longest contour edge;
- `CGAL::Shape_regularization::Direction_type::MULTIPLE` - tries to estimate multiple 
principal directions in the contour based on the input parameters and if not reverts back 
to the default option of the longest edge.

After the directions are set, the algorithm is linear in the number of segments. It goes 
through each contour edge and orients it towards the corresponding principal direction, 
then it tries to merge all the consequent almost collinear edges and inserts orthogonal edges 
wherever it is necessary. Such note that the final result of the algorithm may return a different 
number of edges than were provided as input.

Both open and closed contour algorithms give identical results on the same input.


\subsection Contour_regularization_Closed Closed Contours

In the example below, we regularize a closed contour. We first try to find multiple 
directions but since the original contour is very rectilinear we revert back to the 
direction defined by the contour longest edge. Note that its result is the same as 
for the open contour below.

\cgalFigureBegin{regularize_closed_contour, regularize_closed_contour.png}
A closed contour (red) and its regularized version (black).
\cgalFigureEnd

The pictures are generated by compiling and running the example.

\cgalExample{Shape_regularization/regularize_closed_contour.cpp}


\subsection Contour_regularization_Open Open Contours

Open contours are contours where the head and tail of the contour are not connected,
this case requires a special treatment but the core of the algorithm is the same as 
discussed above. In the example below, we regularize an open contour with respect to 
its longest edge. Note that its result is the same as for the closed contour above.

\cgalFigureBegin{regularize_open_contour, regularize_open_contour.png}
An open contour (red) and its regularized version (black).
\cgalFigureEnd

The pictures are generated by compiling and running the example.

\cgalExample{Shape_regularization/regularize_open_contour.cpp}


\section Shape_regularization_History History

The shape regularization algorithm on a 2D segment set was first implemented by Jean-Philippe Bauchet 
under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer 
of Code 2019 under the supervision of Dmitry Anisimov. Plane regularization was added by Simon Giraudot 
based on the prototype version developed by Florent Lafarge.


\section Shape_regularization_Acknowledgement Acknowledgment

Section on acknowledgment will be here.

*/
} /* namespace CGAL */
