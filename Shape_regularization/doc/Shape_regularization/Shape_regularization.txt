namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Shape_Regularization

\cgalAutoToc
\authors Dmitry Anisimov, Gennadii Sytov, Simon Giraudot, Jean-Philippe Bauchet, and Florent Lafarge

\cgalFigureBegin{regularize_2_overview, overview.svg}
A set of 2D segments and contours before (red) and after (green) regularization.
\cgalFigureEnd


\section Shape_Regularization_Intro Introduction

This \cgal package enables to regularize a set of segments and open or closed contours in 2D
and a set of planes in 3D such that all input objects are rotated and aligned with respect
to the user-defined conditions. This package can also be used in conjunction with
the \ref PkgShapeDetection "Shape Detection" package.


\section QP_Regularization_Segments Segments

Given a set of unordered 2D segments, one can reinforce three types of regularities
among these segments:
- *Parallelism*: segments, which are detected as near parallel, are made exactly parallel.
- *Orthogonality*: segments, which are detected as near orthogonal, are made exactly orthogonal.
- *Collinearity*: parallel segments, which are detected as near collinear, are made exactly collinear.

A typical use of this algorithm consists of the following steps:
1. Create an input range with 2D segments;
2. Define groups of segments, which should be regularized together;
3. Create instances of the classes `NeighborQuery` and `RegularizationType` with the proper parameters;
4. Call the function `CGAL::Shape_regularization::Segments::regularize_segments()`.

Once the user has defined an input range with 2D segments, one can either provide them all
to the regularization algorithm, which is the default option, or they could be reorganized into
groups of contextually similar segments. For example, all segments of the same length could
form a group. When regularizing, only segments within the group are taken into account, that
is no segment from one group will be oriented and/or aligned towards a segment from another group
(see more details \ref QP_Regularization_Segments_Delaunay "here").

To apply the algorithm, one has to define two models: one of the concept `NeighborQuery` that provides
an access to the closest neigbors of a segment; and the other one of the concept `RegularizationType`
that provides one of the available regularities, which should be adjusted.

This \cgal component provides a model of the `NeighborQuery` concept:

- `CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2` - finds local neighbors
of each segment by constructing a Delaunay triangulation. See more details
\ref QP_Regularization_Segments_Delaunay "here".

And two models of the `RegularizationType` concept:

- `CGAL::Shape_regularization::Segments::Angle_regularization_2` - orients segments
to preserve parallelism and orthogonality among them. See more details
\ref QP_Regularization_Segments_Angles "here".
- `CGAL::Shape_regularization::Segments::Offset_regularization_2` - aligns parallel segments
to preserve collinearity among them. See more details
\ref QP_Regularization_Segments_Offset "here".

\remark The core of this algorithm is the \ref QP_Regularization framework. For more details, please
address that section.

The example below shows the most straightforward entry point to the algorithm, where
we apply two type of regularities: parallelism and orthogonality, within the
group of all input segments. The algorithm is called via the function
`CGAL::Shape_regularization::Segments::regularize_segments()`.

\cgalFigureBegin{regularize_simple_example, regularize_simple.svg}
A set of 2D segments before (red) and after (green) the angle regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_simple.cpp}


\subsection QP_Regularization_Segments_Delaunay Delaunay Neighbor Query

This class finds local neighbors of each segment by constructing a
Delaunay triangulation, using the class `CGAL::Delaunay_triangulation_2`, upon the center
points of the input segments. The local neighborhood of a segment is thus defined by
the corresponding one-ring neighborhood in the triangulation. The Delaunay triangulation
can be constructed only for a group of minimum two segments.

The Delaunay neighbor query class constructs the Delaunay triangulation from a group of segments,
which has to be provided by the user through the `CGAL::Shape_regularization::Segments::Delaunay_neighbor_query_2::add_group()`
method, and finds local neighbors of each segment only within the group. If this method
is never called, all input segments are treated as a group.

Note that a group can include fewer segments than in the input range. For example, if your input range
contains multiple segments, which contextually form three different groups of objects lets say
boundaries of three different buildings and you do not want to regularize these buildings with respect to each other,
but rather within each building boundary, in that case you should call the `add_group`
method three times. An example of such groups can be seen in \ref Regularize_15_Segments_Figure "this figure",
where one can see three groups of contextually similar segments: outer boundary, interior top rhombus
and interior bottom rhombus.


\subsection QP_Regularization_Segments_Angles Angle Regularization

This class orients 2D segments in order to preserve parallelism and orthogonality among them.
To apply the angle regularization on a set of 2D segments, the user has to:
- specify the max angle deviation between two segments that has to be within the
interval [0, 90] degrees. If no bound is provided, a bound of 25 degrees will be set as the default value;
- add groups of segments, if any, through the
`CGAL::Shape_regularization::Segments::Angle_regularization_2::add_group()` method.
These groups are identical to the ones from \ref QP_Regularization_Segments_Delaunay.

\cgalFigureBegin{regularize_100_segments_angles_example, regularize_100_segments_angles.svg}
A generated set of 2D segments before (red) and after (green) the angle regularization.
\cgalFigureEnd

The following example demonstrates the usage of the shape regularization algorithm for angles
on a set of 100 near orthogonal segments generated with the help of \ref PkgGenerators "CGAL Geometric Object Generators".
The entire `InputRange` is provided to the angle regularization class as a group.
The max angle bound is set to 40 degrees and the `CGAL::Simple_cartesian<double>` kernel is used.

\cgalExample{Shape_regularization/regularize_100_segments_angles.cpp}


\subsection QP_Regularization_Segments_Offset Offset Regularization

This class aligns 2D parallel segments in order to preserve collinearity among them.
To apply the offset regularization on a set of 2D segments, the user has to:
- specify the max distance between two parallel segments that has to be within the
interval [0, +inf). If no bound is provided, a bound of 0.5 unit length will be set as the default value.
- add groups of parallel segments through the
`CGAL::Shape_regularization::Segments::Offset_regularization_2::add_group()` method.
If the user does not have these groups, they can be obtained from \ref QP_Regularization_Segments_Angles
"Angle Regularization" by orienting original segments or they can be computed by using the utility function
`CGAL::Shape_regularization::Segments::parallel_groups()`. See more details \ref QP_Regularization_Segments_Groups "here".

\cgalFigureBegin{regularize_100_segments_offsets_example, regularize_100_segments_offsets.svg}
A generated set of 2D segments before (red) and after (green) the offset regularization.
\cgalFigureEnd

The following example demonstrates the usage of the shape regularization algorithm for offsets
on a set of 100 parallel segments located within a circle. The function
`CGAL::Shape_regularization::Segments::parallel_groups()` is used to obtain the groups
of parallel segments. The max offset bound is set to 0.25 unit length and the
`CGAL::Simple_cartesian<double>` kernel is used.

\anchor QP_Parallel_Groups_Example
\cgalExample{Shape_regularization/regularize_100_segments_offsets.cpp}


\subsection QP_Regularization_Segments_Examples Examples

The following examples demonstrate the usage of the shape regularization algorithm for
both angles and offsets sequentially on a set of 2D segments.

The first example contains 15 segments. The angle and offset regularizations
are performed on these segments sequentially using the max bounds of 10 degrees and 0.1 unit length
respectively. The `CGAL::Exact_predicates_inexact_constructions_kernel` kernel is used. We also
show here how to create and work with contextually similar groups of segments and
regularize each group on its own. The defined groups are the outer boundary, top and
bottom rhombus. Since the shape regularization algorithm on segments is based on the
\ref QP_Regularization framework, this example also shows how to use that framework
directly instead of calling the function `CGAL::Shape_regularization::Segments::regularize_segments()`.

\anchor Regularize_15_Segments_Figure
\cgalFigureBegin{regularize_15_segments_example, regularize_15_segments.svg}
A set of 2D segments before (red) and after (green) the shape regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_15_segments.cpp}

The second example contains 65 segments, which are constructed from a set of points
obtained with the use of the \ref PkgShapeDetection package. The points are grouped such
that each group represents an approximate 2D line. We fit a segment to each group of
points using the \ref PkgPrincipalComponentAnalysisD "Principal Component Analysis" package.
The angle and offset regularizations are performed on these segments sequentially
using the bounds of 80 degrees and 2 unit lengths respectively.
The `CGAL::Exact_predicates_inexact_constructions_kernel` kernel is used.

\cgalFigureBegin{regularize_real_data_2_example, regularize_real_data_2.svg}
A set of 2D segments before (red) and after (green) the shape regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_real_data_2.cpp}


\subsection QP_Regularization_Segments_Groups Groups

This \cgal component also provides three ways to group segments:
- `CGAL::Shape_regularization::Segments::parallel_groups()` - organizes a set
of unordered 2D segments into groups of parallel segments.
- `CGAL::Shape_regularization::Segments::orthogonal_groups()` - organizes a set
of unordered 2D segments into groups of orthogonal segments.
- `CGAL::Shape_regularization::Segments::collinear_groups()` - organizes a set
of unordered 2D segments into groups of collinear segments.

\cgalFigureBegin{parallel_groups, groups.svg}
Groups of near parallel (left), near orthogonal (center), and near collinear (right) segments.
Red, green, blue colors indicate groups within each set of 2D segments.
\cgalFigureEnd

The function `CGAL::Shape_regularization::Segments::parallel_groups()` enables users
to form groups of parallel segments. For example, if you know that all your segments are already
near parallel to each other within some error and you do not want to orient them by applying
the \ref QP_Regularization_Segments_Angles "Angle Regularization" algorithm, but you still need
to make them collinear by minimizing the offset among parallel segments using the
\ref QP_Regularization_Segments_Offset "Offset Regularization" algorithm, you can
create the groups of parallel segments by using this function and provide them as input
to the offset regularization algorithm as we do it \ref QP_Parallel_Groups_Example "here".

The other two functions serve a similar goal. The one `CGAL::Shape_regularization::Segments::orthogonal_groups()`
first creates groups of parallel segments and then merges them into groups, where all
segments are either parallel or orthogonal to each other. The one `CGAL::Shape_regularization::Segments::collinear_groups()`
first creates groups of parallel segments and then splits each of these groups
into groups of collinear segments, if any.


\section Contour_Regularization Contours

Given a set of ordered 2D points connected by segments, which form a contour, closed
or open, one can reinforce three types of regularities among consecutive edges of this contour:
- *Parallelism*: contour edges, which are detected as near parallel, are made exactly parallel.
- *Orthogonality*: contour edges, which are detected as near orthogonal, are made exactly orthogonal.
- *Collinearity*: parallel contour edges, which are detected as near collinear, are made exactly collinear.

A typical use of this algorithm consists of the following steps:
1. Specify a type of the contour, open or closed;
2. Create an instance of the class `ContourDirections` with the proper parameters;
3. Call the function `CGAL::Shape_regularization::Segments::regularize_closed_contour()`
or `CGAL::Shape_regularization::Segments::regularize_open_contour()`.

We assume that each contour has at least one principal direction that is a reference
direction towards which the contour edges are either rotated or displaced. Given a
user defined max angle deviation between an edge and a principal direction and max distance
between two consecutive edges, each edge within these thresholds is made either parallel,
collinear or orthogonal to the reference direction(s).

\cgalFigureBegin{multiple_directions, multiple_directions.svg}
A closed contour before (red) and after (green) the contour regularization.
The found principal directions are marked yellow.
\cgalFigureEnd

To estimate principal directions of the contour, this component provides three
models of the concept `ContourDirections`:
- `CGAL::Shape_regularization::Contours::Longest_direction_2` - sets the longest contour edge
as the only principal direction.
- `CGAL::Shape_regularization::Contours::Multiple_directions_2` - tries to estimate multiple
principal directions in the contour based on the user-defined parameters.
- `CGAL::Shape_regularization::Contours::User_defined_directions_2` - sets the user-defined
principal directions as contour directions.

After the directions are set, the algorithm is linear in the number of contour edges. It goes
through each contour edge and orients it towards the best-fit direction, then it tries to
merge consecutive parallel edges, if they are within the user-defined max distance
threshold, and inserts orthogonal edges wherever it is necessary. Note that the final result
of the algorithm may return a different number of edges than were provided as input.

If one wants to rotate each contour edge on its own towards the best-fit direction
without reconnecting them after into a closed/open contour, one can either use the
\ref QP_Regularization_Segments "Segment Regularization" algorithm or one can orient
each segment by calling the `ContourDirections::orient()` method.


\subsection Contour_Regularization_Closed Closed

In the example below, we regularize a closed contour. We first try to find multiple
directions, but since the original contour is very rectilinear, we revert back to the
direction defined by the longest contour edge. The used kernel is
`Exact_predicates_inexact_constructions_kernel`.

\cgalFigureBegin{regularize_closed_contour_example, regularize_closed_contour.svg}
A closed contour before (red) and after (green) the contour regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_closed_contour.cpp}


\subsection Contour_Regularization_Open Open

Open contours are contours where the head and tail of the contour are not connected.
This case requires a special treatment, but the core of the algorithm is the same.
In the example below, we regularize an open contour with respect to
its longest edge. The used kernel is `Exact_predicates_exact_constructions_kernel`.
Though this exact kernel provides better quality results, please note that it may
significantly slow down the execution of the program, so if you need a faster version
of the algorithm, use a floating type based kernel. This example also shows how to
provide a property map in the algorithm in order to give the algorithm access to
the coordinates of the contour vertices.

\cgalFigureBegin{regularize_open_contour_example, regularize_open_contour.svg}
An open contour before (red) and after (green) the contour regularization.
\cgalFigureEnd

\cgalExample{Shape_regularization/regularize_open_contour.cpp}


\section Plane_Regularization Planes

Here, we provide all available \cgal algorithms that enable to regularize 3D planes.


\subsection Plane_Regularization_Hierarchy Hierarchical Regularization

Given a set of 3D planes with their corresponding inlier sets, one can reinforce four
types of regularities among these planes using the function
`CGAL::Shape_regularization::Segments::regularize_planes()`:
- *Parallelism*: planes, which are detected as near parallel, are made exactly parallel.
- *Orthogonality*: planes, which are detected as near orthogonal, are made exactly orthogonal.
- *Coplanarity*: parallel planes, which are detected as near coplanar, are made exactly coplanar.
- *Axis-Symmetry*: planes, which are detected as near symmetrical with respect to a user-defined axis,
are made exactly symmetrical.

The user can choose to regularize only one or several of these four properties.
The process is greedy and based on a hierarchical decomposition (coplanar clusters are subgroups of parallel clusters,
which are subgroups of axis-symmetric and orthogonal clusters) as described by Verdie et al. in \cgalCite{cgal:vla-lod-15}.

The following example illustrates how to use the plane regularization function.
The used kernel is `Exact_predicates_inexact_constructions_kernel`.

\cgalExample{Shape_regularization/regularize_planes.cpp}

\remark Please note that this function was earlier used in the \ref PkgShapeDetection package. You can
still use the old API of that function, however to avoid parameters ambiguity, we strongly
suggest to use the new API with the \ref sr_namedparameters "Named Parameters" mechanism.


\section QP_Regularization QP Regularization

The shape regularization component is a generic framework that is based on the
Quadratic Programming (QP) global regularization algorithm \cgalCite{cgal:bl-kippi-18}
by Bauchet et Lafarge. You should address this section only if you want to know details
on how the shape regularization framework is organized internally or you want to extend
it by implementing your own regularization types.

Two particular instances of this algorithm are provided:
- `CGAL::Shape_regularization::Segments::Angle_regularization_2` - orients a set
of unordered 2D segments. See \ref QP_Regularization_Segments_Angles "Angle Regularization" for more details.

- `CGAL::Shape_regularization::Segments::Offset_regularization_2` - aligns a set
of parallel 2D segments. See \ref QP_Regularization_Segments_Offset "Offset Regularization" for more details.

Other instances can be added by the user, as explained \ref QP_Regularization_Implementation "here".


\subsection QP_Regularization_Framework Framework

This framework follows Section three .... (TO BE ADDED)

The main class `CGAL::Shape_regularization::QP_regularization` is parameterized by:
- `NeighborQuery` that provides the means for accessing local neighbors of an item,
- `RegularizationType` that determines a regularization type to be applied, and
- `QPSolver` that is used to define and solve the corresponding QP problem.

Within this generic framework, users can regularize any set of input items provided
their own neighbor search, regularization type, and QP solver.


\subsection QP_Regularization_Neighborhood Neighborhood

The concept `NeighborQuery` provides the means for accessing local neighbors of an item.
To create a model that respects this concept, the user has to provide an overload of the operator:

- `NeighborQuery::operator()()` that has to fill in a vector with indices of all items, which
are neighbors of the query item.

For example, given a segment, this operator may return a vector with indices of some other
input segments, which are within a certain distance from this segment, however this distance
is measured. See \ref QP_Regularization_Segments_Delaunay "this section" for more details.


\subsection QP_Regularization_Type Regularization

The concept `RegularizationType` determines a type of regularization to be applied.
To create a model that respects this concept, three functions have to be defined:

- `RegularizationType::target()` a function that estimates a type of regularity between two neighbors,
- `RegularizationType::bound()` a function that returns a max bound on the allowed regularity change, and
- `RegularizationType::update()` a function that updates input items with respect to the modified regularities.

For example, if we want to regularize segment orientations, that is to make segments parallel and orthogonal
to each other, the first function should return an angle between a query segment and each of its neighbors;
the second function should return a max angle within which a rotation of the query segment is accepted;
and the third function should apply the new segment orientations computed by the QP solver to
the initial input segments. See \ref QP_Regularization_Segments_Angles "this section" for more details.


\subsection QP_Regularization_Solvers Solvers

In order to solve the associated QP problem of the algorithm above, \cgal provides
two particular models of the corresponding QP solver:
- `CGAL::Shape_regularization::CGAL_quadratic_program` that is a \cgal QP solver, and
- `CGAL::Shape_regularization::OSQP_quadratic_program` that is a wrapper of the external \ref thirdpartyOSQP "OSQP solver".

Since the internal quadratic program that has to be solved is sparse, we recommend using the second
solver, because the \cgal version will internally convert this problem into a dense one that takes
considerable effort to solve, while the OSQP version is sparse and very efficient. Both solvers
follow the `QPSolver` concept and thus users are free to provide their own version of the solver.


\subsection QP_Regularization_Implementation Implementation

If you want to implement your own regularization approach that follows the same
framework, for example to reinforce a different type of regularity than is already provided,
you have to implement your own model of the \ref QP_Regularization_Type "RegularizationType"
concept and possibly a model of the \ref QP_Regularization_Neighborhood "NeighborQuery" concept.
These concepts are used to parameterize the main `CGAL::Shape_regularization::QP_regularization` algorithm:
1. Use `NeighborQuery` to find local neighbors of each input item;
2. Use `RegularizationType` to estimate current regularities among these neighbors;
3. Use `RegularizationType` to set max bounds on the allowed regularity changes;
4. Use `QPSolver` to solve the quadratic programming problem;
5. Use `RegularizationType` to update input items with respect to the modified regularities.

In addition, the user may also want to change a \ref QP_Regularization_Solvers "QP solver"
if one knows how to optimize it for a specific type of input data. To do that, one
has to implement a model of the `QPSolver` concept.

An example below shows how to define your own type of the above concepts and how to
choose among available solvers.

\cgalExample{Shape_regularization/regularize_framework.cpp}


\subsection QP_Regularization_Performance Performance

The shape regularization algorithm is very efficient. In the setup phase, it has
a linear level of complexity to obtain local neighbors of each item, compute all objective
function values, and construct the QP problem data. In the solve phase, when using the
`CGAL::Shape_regularization::OSQP_quadratic_program`, we exploit and efficiently use the sparse
nature of the related QP problem that leads to the quick performance in practice
(see the table and graph below).

This table includes some timings of running several representative examples from this manual.

<table class="markdownTable" align="center">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Example </th><th class="markdownTableHeadCenter">Number of segments </th><th class="markdownTableHeadCenter">Number of modified segments: Angle regularization  </th><th class="markdownTableHeadCenter">Number of modified segments: Offset regularization  </th><th class="markdownTableHeadCenter">Time (in seconds): Angle regularization </th><th class="markdownTableHeadCenter">Time (in seconds): Offset regularization </th></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_15_segments  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">15  </td><td class="markdownTableBodyCenter">11  </td><td class="markdownTableBodyCenter">0.000247   </td><td class="markdownTableBodyCenter">0.000140   </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_100_segments_angles  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A  </td><td class="markdownTableBodyCenter">0.002310   </td><td class="markdownTableBodyCenter">N/A  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_100_segments_offsets  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A  </td><td class="markdownTableBodyCenter">100  </td><td class="markdownTableBodyCenter">N/A   </td><td class="markdownTableBodyCenter">0.001109  </td></tr>
<tr class="markdownTableBody">
<td class="markdownTableBodyCenter">regularize_real_data_2  </td><td class="markdownTableBodyCenter">65  </td><td class="markdownTableBodyCenter">65 </td><td class="markdownTableBodyCenter">64  </td><td class="markdownTableBodyCenter">0.001873   </td><td class="markdownTableBodyCenter">0.000396  </td></tr>
</table>

We also present a graph (TO BE ADDED LATER) that shows how the QP regularization performance depends on
the number of input segments.


\section Shape_Regularization_History History

The shape regularization algorithm for 2D segments was first implemented by Jean-Philippe Bauchet
under the supervision of Florent Lafarge and then generalized by Gennadii Sytov during the Google Summer
of Code 2019 under the supervision of Dmitry Anisimov. The contour regularization algorithm was
developed and implemented by Dmitry Anisimov and Simon Giraudot. Plane regularization
was added by Simon Giraudot based on the prototype version developed by Florent Lafarge.


\section Shape_Regularization_Acknowledgements Acknowledgments

We wish to thank Andreas Fabri and Marc Pouget for useful discussions and reviews.

*/
} /* namespace CGAL */
